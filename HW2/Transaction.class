//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by Fernflower decompiler)
//

import java.nio.ByteBuffer;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.PublicKey;
import java.security.interfaces.RSAPublicKey;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;

public class Transaction {
    private byte[] hash;
    private ArrayList<Transaction.Input> inputs;
    private ArrayList<Transaction.Output> outputs;
    private boolean coinbase;

    public Transaction() {
        this.inputs = new ArrayList();
        this.outputs = new ArrayList();
        this.coinbase = false;
    }

    public Transaction(Transaction tx) {
        this.hash = (byte[])tx.hash.clone();
        this.inputs = new ArrayList(tx.inputs);
        this.outputs = new ArrayList(tx.outputs);
        this.coinbase = false;
    }

    public Transaction(double coin, PublicKey address) {
        this.coinbase = true;
        this.inputs = new ArrayList();
        this.outputs = new ArrayList();
        this.addOutput(coin, address);
        this.finalize();
    }

    public boolean isCoinbase() {
        return this.coinbase;
    }

    public void addInput(byte[] prevTxHash, int outputIndex) {
        Transaction.Input in = new Transaction.Input(prevTxHash, outputIndex);
        this.inputs.add(in);
    }

    public void addOutput(double value, PublicKey address) {
        Transaction.Output op = new Transaction.Output(value, address);
        this.outputs.add(op);
    }

    public void removeInput(int index) {
        this.inputs.remove(index);
    }

    public void removeInput(UTXO ut) {
        for(int i = 0; i < this.inputs.size(); ++i) {
            Transaction.Input in = (Transaction.Input)this.inputs.get(i);
            UTXO u = new UTXO(in.prevTxHash, in.outputIndex);
            if (u.equals(ut)) {
                this.inputs.remove(i);
                return;
            }
        }

    }

    public byte[] getRawDataToSign(int index) {
        ArrayList<Byte> sigData = new ArrayList();
        if (index > this.inputs.size()) {
            return null;
        } else {
            Transaction.Input in = (Transaction.Input)this.inputs.get(index);
            byte[] prevTxHash = in.prevTxHash;
            ByteBuffer b = ByteBuffer.allocate(4);
            b.putInt(in.outputIndex);
            byte[] outputIndex = b.array();
            int i;
            if (prevTxHash != null) {
                for(i = 0; i < prevTxHash.length; ++i) {
                    sigData.add(prevTxHash[i]);
                }
            }

            for(i = 0; i < outputIndex.length; ++i) {
                sigData.add(outputIndex[i]);
            }

            Iterator var8 = this.outputs.iterator();

            while(var8.hasNext()) {
                Transaction.Output op = (Transaction.Output)var8.next();
                ByteBuffer bo = ByteBuffer.allocate(8);
                bo.putDouble(op.value);
                byte[] value = bo.array();
                byte[] addressExponent = ((RSAPublicKey)op.address).getPublicExponent().toByteArray();
                byte[] addressModulus = ((RSAPublicKey)op.address).getModulus().toByteArray();

                int i;
                for(i = 0; i < value.length; ++i) {
                    sigData.add(value[i]);
                }

                for(i = 0; i < addressExponent.length; ++i) {
                    sigData.add(addressExponent[i]);
                }

                for(i = 0; i < addressModulus.length; ++i) {
                    sigData.add(addressModulus[i]);
                }
            }

            byte[] sigD = new byte[sigData.size()];
            int i = 0;

            Byte sb;
            for(Iterator var18 = sigData.iterator(); var18.hasNext(); sigD[i++] = sb) {
                sb = (Byte)var18.next();
            }

            return sigD;
        }
    }

    public void addSignature(byte[] signature, int index) {
        ((Transaction.Input)this.inputs.get(index)).addSignature(signature);
    }

    public byte[] getRawTx() {
        ArrayList<Byte> rawTx = new ArrayList();
        Iterator var3 = this.inputs.iterator();

        while(true) {
            byte[] addressModulus;
            int i;
            do {
                byte[] addressExponent;
                if (!var3.hasNext()) {
                    var3 = this.outputs.iterator();

                    while(var3.hasNext()) {
                        Transaction.Output op = (Transaction.Output)var3.next();
                        ByteBuffer b = ByteBuffer.allocate(8);
                        b.putDouble(op.value);
                        byte[] value = b.array();
                        addressExponent = ((RSAPublicKey)op.address).getPublicExponent().toByteArray();
                        addressModulus = ((RSAPublicKey)op.address).getModulus().toByteArray();

                        for(i = 0; i < value.length; ++i) {
                            rawTx.add(value[i]);
                        }

                        for(i = 0; i < addressExponent.length; ++i) {
                            rawTx.add(addressExponent[i]);
                        }

                        for(i = 0; i < addressModulus.length; ++i) {
                            rawTx.add(addressModulus[i]);
                        }
                    }

                    byte[] tx = new byte[rawTx.size()];
                    int i = 0;

                    Byte b;
                    for(Iterator var15 = rawTx.iterator(); var15.hasNext(); tx[i++] = b) {
                        b = (Byte)var15.next();
                    }

                    return tx;
                }

                Transaction.Input in = (Transaction.Input)var3.next();
                byte[] prevTxHash = in.prevTxHash;
                ByteBuffer b = ByteBuffer.allocate(4);
                b.putInt(in.outputIndex);
                addressExponent = b.array();
                addressModulus = in.signature;
                if (prevTxHash != null) {
                    for(i = 0; i < prevTxHash.length; ++i) {
                        rawTx.add(prevTxHash[i]);
                    }
                }

                for(i = 0; i < addressExponent.length; ++i) {
                    rawTx.add(addressExponent[i]);
                }
            } while(addressModulus == null);

            for(i = 0; i < addressModulus.length; ++i) {
                rawTx.add(addressModulus[i]);
            }
        }
    }

    public void finalize() {
        try {
            MessageDigest md = MessageDigest.getInstance("SHA-256");
            md.update(this.getRawTx());
            this.hash = md.digest();
        } catch (NoSuchAlgorithmException var2) {
            var2.printStackTrace(System.err);
        }

    }

    public void setHash(byte[] h) {
        this.hash = h;
    }

    public byte[] getHash() {
        return this.hash;
    }

    public ArrayList<Transaction.Input> getInputs() {
        return this.inputs;
    }

    public ArrayList<Transaction.Output> getOutputs() {
        return this.outputs;
    }

    public Transaction.Input getInput(int index) {
        return index < this.inputs.size() ? (Transaction.Input)this.inputs.get(index) : null;
    }

    public Transaction.Output getOutput(int index) {
        return index < this.outputs.size() ? (Transaction.Output)this.outputs.get(index) : null;
    }

    public int numInputs() {
        return this.inputs.size();
    }

    public int numOutputs() {
        return this.outputs.size();
    }

    public boolean equals(Object other) {
        if (other == null) {
            return false;
        } else if (this.getClass() != other.getClass()) {
            return false;
        } else {
            Transaction tx = (Transaction)other;
            if (tx.numInputs() != this.numInputs()) {
                return false;
            } else {
                int i;
                for(i = 0; i < this.numInputs(); ++i) {
                    if (!this.getInput(i).equals(tx.getInput(i))) {
                        return false;
                    }
                }

                if (tx.numOutputs() != this.numOutputs()) {
                    return false;
                } else {
                    for(i = 0; i < this.numOutputs(); ++i) {
                        if (!this.getOutput(i).equals(tx.getOutput(i))) {
                            return false;
                        }
                    }

                    return true;
                }
            }
        }
    }

    public int hashCode() {
        int hash = 1;

        int i;
        for(i = 0; i < this.numInputs(); ++i) {
            hash = hash * 31 + this.getInput(i).hashCode();
        }

        for(i = 0; i < this.numOutputs(); ++i) {
            hash = hash * 31 + this.getOutput(i).hashCode();
        }

        return hash;
    }

    public class Input {
        public byte[] prevTxHash;
        public int outputIndex;
        public byte[] signature;

        public Input(byte[] prevHash, int index) {
            if (prevHash == null) {
                this.prevTxHash = null;
            } else {
                this.prevTxHash = Arrays.copyOf(prevHash, prevHash.length);
            }

            this.outputIndex = index;
        }

        public void addSignature(byte[] sig) {
            if (sig == null) {
                this.signature = null;
            } else {
                this.signature = Arrays.copyOf(sig, sig.length);
            }

        }

        public boolean equals(Object other) {
            if (other == null) {
                return false;
            } else if (this.getClass() != other.getClass()) {
                return false;
            } else {
                Transaction.Input in = (Transaction.Input)other;
                if (this.prevTxHash.length != in.prevTxHash.length) {
                    return false;
                } else {
                    int i;
                    for(i = 0; i < this.prevTxHash.length; ++i) {
                        if (this.prevTxHash[i] != in.prevTxHash[i]) {
                            return false;
                        }
                    }

                    if (this.outputIndex != in.outputIndex) {
                        return false;
                    } else if (this.signature.length != in.signature.length) {
                        return false;
                    } else {
                        for(i = 0; i < this.signature.length; ++i) {
                            if (this.signature[i] != in.signature[i]) {
                                return false;
                            }
                        }

                        return true;
                    }
                }
            }
        }

        public int hashCode() {
            int hash = 1;
            int hashx = hash * 17 + Arrays.hashCode(this.prevTxHash);
            hashx = hashx * 31 + this.outputIndex;
            hashx = hashx * 31 + Arrays.hashCode(this.signature);
            return hashx;
        }
    }

    public class Output {
        public double value;
        public PublicKey address;

        public Output(double v, PublicKey addr) {
            this.value = v;
            this.address = addr;
        }

        public boolean equals(Object other) {
            if (other == null) {
                return false;
            } else if (this.getClass() != other.getClass()) {
                return false;
            } else {
                Transaction.Output op = (Transaction.Output)other;
                if (this.value != op.value) {
                    return false;
                } else if (!((RSAPublicKey)this.address).getPublicExponent().equals(((RSAPublicKey)op.address).getPublicExponent())) {
                    return false;
                } else {
                    return ((RSAPublicKey)this.address).getModulus().equals(((RSAPublicKey)op.address).getModulus());
                }
            }
        }

        public int hashCode() {
            int hash = 1;
            int hashx = hash * 17 + (int)this.value * 10000;
            hashx = hashx * 31 + ((RSAPublicKey)this.address).getPublicExponent().hashCode();
            hashx = hashx * 31 + ((RSAPublicKey)this.address).getModulus().hashCode();
            return hashx;
        }
    }
}
