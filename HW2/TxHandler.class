//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by Fernflower decompiler)
//

import Transaction.Input;
import Transaction.Output;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

public class TxHandler {
    private UTXOPool utxoPool;

    public TxHandler(UTXOPool utxoPool) {
        this.utxoPool = new UTXOPool(utxoPool);
    }

    public boolean isValidTx(Transaction tx) {
        UTXOPool uniqueUtxos = new UTXOPool();
        double previousTxOutSum = 0.0D;
        double currentTxOutSum = 0.0D;

        for(int i = 0; i < tx.numInputs(); ++i) {
            Input in = tx.getInput(i);
            UTXO utxo = new UTXO(in.prevTxHash, in.outputIndex);
            Output output = this.utxoPool.getTxOutput(utxo);
            if (!this.utxoPool.contains(utxo)) {
                return false;
            }

            if (!Crypto.verifySignature(output.address, tx.getRawDataToSign(i), in.signature)) {
                return false;
            }

            if (uniqueUtxos.contains(utxo)) {
                return false;
            }

            uniqueUtxos.addUTXO(utxo, output);
            previousTxOutSum += output.value;
        }

        Output out;
        for(Iterator var12 = tx.getOutputs().iterator(); var12.hasNext(); currentTxOutSum += out.value) {
            out = (Output)var12.next();
            if (out.value < 0.0D) {
                return false;
            }
        }

        return previousTxOutSum >= currentTxOutSum;
    }

    public Transaction[] handleTxs(Transaction[] possibleTxs) {
        Set<Transaction> validTxs = new HashSet();
        Transaction[] var6 = possibleTxs;
        int var5 = possibleTxs.length;

        for(int var4 = 0; var4 < var5; ++var4) {
            Transaction tx = var6[var4];
            if (this.isValidTx(tx)) {
                validTxs.add(tx);
                Iterator var8 = tx.getInputs().iterator();

                UTXO utxo;
                while(var8.hasNext()) {
                    Input in = (Input)var8.next();
                    utxo = new UTXO(in.prevTxHash, in.outputIndex);
                    this.utxoPool.removeUTXO(utxo);
                }

                for(int i = 0; i < tx.numOutputs(); ++i) {
                    Output out = tx.getOutput(i);
                    utxo = new UTXO(tx.getHash(), i);
                    this.utxoPool.addUTXO(utxo, out);
                }
            }
        }

        Transaction[] validTxArray = new Transaction[validTxs.size()];
        return (Transaction[])validTxs.toArray(validTxArray);
    }

    public UTXOPool getUTXOPool() {
        return null;
    }
}
